#version 460
#extension GL_GOOGLE_include_directive : enable

// #include "materials.comp"
#include "camera.comp"

#include "utils.comp"
#include "ray.comp"

//#define FLT_MAX 3.402823466e+38
#define FLT_MAX 99999.99
//const float INFINITY     = 1. / 0.;

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0) uniform ComputeParams {
  vec3  background;
  float fWidth;
  float fHeight;
  float fSamplesPerPixel;
  float fMaxBounces;
  float fRandomSeed;
}
params;

layout(std140, set = 0, binding = 2) buffer PixelBuffer {
  vec4 pixels[];
}
pixelBuffer;

layout(std140, set = 0, binding = 3) buffer AccumlationBuffer {
  vec4 pixels[];
}
accumulationBuffer;

#include "./hittable/hittable.comp"
#include "./material/material.comp"

vec3 rayColor(Ray ray, vec3 background, uint depth) {
  HitRecord rec;
  vec3      color = vec3(1.0, 1.0, 1.0);

  for (int i = 0; i < depth; i++) {
    if (hittableListHit(ray, 0.001, FLT_MAX, rec)) {
      Ray  newRay;
      vec3 attenuation;
      vec3 emitted      = materialEmitted(ray, rec);
      bool wasScattered = materialScatter(ray, rec, attenuation, newRay);

      ray = newRay;

      if (wasScattered) {
        color *= (emitted + attenuation);
      } else {
        color *= emitted;
        break;
      }
    } else {
      color *= background;
      break;
    }

    // ivec2 o = hittableList[1].object;
    // color = vec3(o.xy, 1.0);
  }

  return color;
}

void main() {
  uvec3 index = gl_GlobalInvocationID;

  // float j = params.fHeight - (floor(float(index.x) / params.fWidth));
  // float i = mod(float(index.y), params.fWidth);
  float i = index.x;
  float j = params.fHeight - index.y;

  //initSeed(index * 1099087573U);
  initSeed(index.x * index.y * uint(floor(params.fRandomSeed * 1000000000U)));

  vec3 pixelColor = vec3(0.0, 0.0, 0.0);

  const uint ssp     = uint(params.fSamplesPerPixel);
  const uint bounces = uint(params.fMaxBounces);

  const float rnd = random();

  // for (int s = 0; s < ssp; s++) {
  float u = (i + rnd) / (params.fWidth - 1.0);
  float v = (j + rnd) / (params.fHeight - 1.0);
  Ray   r = cameraGetRay(u, v);
  pixelColor += rayColor(r, params.background, bounces);
  // }

  const uint pixelIndex                     = index.y * uint(params.fWidth) + index.x;
  const vec3 accumulatedColor               = accumulationBuffer.pixels[pixelIndex].rgb + pixelColor;
  pixelColor                                = accumulatedColor * (1.0 / ssp);
  accumulationBuffer.pixels[pixelIndex].rgb = accumulatedColor;

  // gamma correction 2.0
  // pixelColor = sqrt(pixelColor);

  // gamma correction 2.2
  pixelColor = pow(pixelColor, vec3(1.0 / 2.2));

  pixelBuffer.pixels[pixelIndex] = vec4(pixelColor, 1.0);
}

/*

  0 1 2 3
0 * * * *
1 * * * *
2 * * * *
3 * * * *

11

*/
