#ifndef TRIANGLE_INC
#define TRIANGLE_INC

#extension GL_GOOGLE_include_directive : enable

#include "../ray.comp"
#include "../utils.comp"
#include "./hittable_base.comp"

#define EPSILON 0.0000001

bool hitTriangle(const Primitive tri, const Ray ray, const float tMin, const float tMax, inout HitRecord rec) {
  vec3 v0 = tri.v0.xyz;
  vec3 v1 = tri.v1.xyz;
  vec3 v2 = tri.v2.xyz;

  vec3 edge1 = v1 - v0;
  vec3 edge2 = v2 - v0;

  vec3  h = cross(ray.direction, edge2);
  float a = dot(edge1, h);

  if (a > -EPSILON && a < EPSILON) {
    return false;  // ray is parallel to the tri
  }

  float f = 1.0 / a;
  vec3  s = ray.origin - v0;
  float u = f * dot(s, h);

  if (u < 0.0 || u > 1.0) {
    return false;
  }

  vec3  q = cross(s, edge1);
  float v = f * dot(ray.direction, q);

  if (v < 0.0 || u + v > 1.0) {
    return false;
  }

  // At this stage we can compute t to find out where the intersection point is on the line.
  float t = f * dot(edge2, q);
  if (t > EPSILON) {
    rec.t             = t;
    rec.p             = rayAt(ray, rec.t);
    rec.materialIndex = tri.materialIndex;

    float w = 1.0 - u - v;

    vec4 n0 = tri.n0 * w;
    vec4 n1 = tri.n0 * u;
    vec4 n2 = tri.n0 * v;

    vec3 outwardNormal = normalize((n0 + n1 + n2).xyz);
    setFaceNormal(rec, ray, outwardNormal);

    // FIXME: this is only a hack, to avoid backfacing faces to show up
    if (!rec.frontFace) {
      return false;
    }

    // TODO: UV
    return true;
  }

  return false;
}

#endif  // TRIANGLE_INC

/*
bool RayIntersectsTriangle(Vector3D rayOrigin, 
                           Vector3D rayVector, 
                           Triangle* inTriangle,
                           Vector3D& outIntersectionPoint)
{
    const float EPSILON = 0.0000001;
    Vector3D vertex0 = inTriangle->vertex0;
    Vector3D vertex1 = inTriangle->vertex1;  
    Vector3D vertex2 = inTriangle->vertex2;
    Vector3D edge1, edge2, h, s, q;
    float a,f,u,v;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = rayVector.crossProduct(edge2);
    a = edge1.dotProduct(h);
    if (a > -EPSILON && a < EPSILON)
        return false;    // This ray is parallel to this triangle.
    f = 1.0/a;
    s = rayOrigin - vertex0;
    u = f * s.dotProduct(h);
    if (u < 0.0 || u > 1.0)
        return false;
    q = s.crossProduct(edge1);
    v = f * rayVector.dotProduct(q);
    if (v < 0.0 || u + v > 1.0)
        return false;
    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * edge2.dotProduct(q);
    if (t > EPSILON) // ray intersection
    {
        outIntersectionPoint = rayOrigin + rayVector * t;
        return true;
    }
    else // This means that there is a line intersection but not a ray intersection.
        return false;
}
*/