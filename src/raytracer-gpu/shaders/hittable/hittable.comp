#ifndef HITTABLE_INC
#define HITTABLE_INC

#extension GL_GOOGLE_include_directive : enable

#define HITTABLETYPE_SPHERE 0
#define HITTABLETYPE_MOVINGSPHERE 1
#define HITTABLETYPE_XYRECT 2
#define HITTABLETYPE_XZRECT 3
#define HITTABLETYPE_YZRECT 4
#define HITTABLETYPE_BOX 5
#define HITTABLETYPE_CONSTANTMEDIUM 6

#include "../ray.comp"
#include "./hittable_base.comp"
#include "./sphere.comp"
#include "./movingsphere.comp"
#include "./rect.comp"

bool hitPrimitive(const Primitive primitve, const Ray ray, const float tMin, const float tMax, inout HitRecord rec) {
  uint primitiveType = primitve.primitiveType;

  mat4 rotationMatrix = mat4(
      primitve.modelMatrix[0],
      primitve.modelMatrix[1],
      primitve.modelMatrix[2],
      vec4(0.0, 0.0, 0.0, 1.0));

  Ray transformedRay = Ray(
      (inverse(primitve.modelMatrix) * vec4(ray.origin, 1.0)).xyz,
      (inverse(rotationMatrix) * vec4(ray.direction, 1.0)).xyz,
      // ray.direction,
      ray.time);

  bool hitted;

  switch (primitiveType) {
    case HITTABLETYPE_SPHERE:
      hitted = hitSphere(primitve, transformedRay, tMin, tMax, rec);
      break;
    case HITTABLETYPE_MOVINGSPHERE:
      hitted = hitMovingSphere(primitve, transformedRay, tMin, tMax, rec);
      break;
    case HITTABLETYPE_XYRECT:
      hitted = hitXYRect(primitve, transformedRay, tMin, tMax, rec);
      break;
    case HITTABLETYPE_XZRECT:
      hitted = hitXZRect(primitve, transformedRay, tMin, tMax, rec);
      break;
    case HITTABLETYPE_YZRECT:
      hitted = hitYZRect(primitve, transformedRay, tMin, tMax, rec);
      break;
  }

  if (hitted) {
    rec.p             = (primitve.modelMatrix * vec4(rec.p, 1.0)).xyz;
    vec3 transformedN = (rotationMatrix * vec4(rec.normal, 1.0)).xyz;
    setFaceNormal(rec, transformedRay, transformedN);
  }

  return hitted;
}

bool hittableListHit(const Ray ray, const float tMin, const float tMax, inout HitRecord rec) {
  HitRecord tempRec;
  bool      hitAnything  = false;
  float     closestSoFar = tMax;

  for (int i = 0; i < primitives.length(); i++) {
    Primitive primitve = primitives[i];

    if (primitve.isVolumetric != 0u) {
      HitRecord rec1;
      HitRecord rec2;

      if (!hitPrimitive(primitve, ray, NEGATIVE_FLT_MAX, FLT_MAX, rec1)) {
        continue;
      }

      hitAnything  = true;
      closestSoFar = rec1.t;
      rec          = rec1;

      if (!hitPrimitive(primitve, ray, rec1.t + 0.0001, FLT_MAX, rec2)) {
        continue;
      }

      // hitAnything = true;

      // if (rec1.t < tMin) {
      //   rec1.t = tMin;
      // }

      // if (rec2.t > tMax) {
      //   rec2.t = tMax;
      // }

      // if (rec1.t >= rec2.t) {
      //   continue;
      // }

      // if (rec1.t < 0.0) {
      //   rec1.t = 0.0;
      // }

      // float rayLength              = length(ray.direction);
      // float distanceInsideBoundary = (rec2.t - rec1.t) * rayLength;
      // float hitDistance            = primitve.negativeInverseDensity * log(random());

      // if (hitDistance > distanceInsideBoundary) {
      //   continue;
      // }

      // rec.t         = rec1.t + hitDistance / rayLength;
      // rec.p         = rayAt(ray, rec.t);
      // rec.normal    = vec3(1.0, 0.0, 0.0);
      // rec.frontFace = true;

      // rec.materialIndex     = primitve.materialIndex;
      // rec.isoTropicMaterial = true;
      // closestSoFar          = rec.t;
      // hitAnything           = true;

    } else {
      if (hitPrimitive(primitve, ray, tMin, closestSoFar, tempRec)) {
        hitAnything  = true;
        closestSoFar = tempRec.t;
        rec          = tempRec;
      }
    }
  }

  return hitAnything;
}

#endif  //HITTABLE_INC
